/**
 * (C) Copyright IBM Corp. 2024.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * IBM OpenAPI SDK Code Generator Version: 3.70.0-7df966bf-20230419-195904
 */

/* eslint-disable max-classes-per-file */
/* eslint-disable no-await-in-loop */

import * as extend from 'extend';
import { IncomingHttpHeaders, OutgoingHttpHeaders } from 'http';
import {
  Authenticator,
  BaseService,
  getAuthenticatorFromEnvironment,
  validateParams,
  UserOptions,
} from 'ibm-cloud-sdk-core';
import { getSdkHeaders } from '../lib/common';
import { getQueryParam } from 'ibm-cloud-sdk-core';

/**
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API Version: 1.0
 */

class EventNotificationsV1 extends BaseService {
  static DEFAULT_SERVICE_URL: string =
    'https://us-south.event-notifications.cloud.ibm.com/event-notifications';

  static DEFAULT_SERVICE_NAME: string = 'event_notifications';

  /*************************
   * Factory method
   ************************/

  /**
   * Constructs an instance of EventNotificationsV1 with passed in options and external configuration.
   *
   * @param {UserOptions} [options] - The parameters to send to the service.
   * @param {string} [options.serviceName] - The name of the service to configure
   * @param {Authenticator} [options.authenticator] - The Authenticator object used to authenticate requests to the service
   * @param {string} [options.serviceUrl] - The URL for the service
   * @returns {EventNotificationsV1}
   */

  public static newInstance(options: UserOptions): EventNotificationsV1 {
    options = options || {};

    if (!options.serviceName) {
      options.serviceName = this.DEFAULT_SERVICE_NAME;
    }
    if (!options.authenticator) {
      options.authenticator = getAuthenticatorFromEnvironment(options.serviceName);
    }
    const service = new EventNotificationsV1(options);
    service.configureService(options.serviceName);
    if (options.serviceUrl) {
      service.setServiceUrl(options.serviceUrl);
    }
    return service;
  }

  /**
   * Construct a EventNotificationsV1 object.
   *
   * @param {Object} options - Options for the service.
   * @param {string} [options.serviceUrl] - The base url to use when contacting the service. The base url may differ between IBM Cloud regions.
   * @param {OutgoingHttpHeaders} [options.headers] - Default headers that shall be included with every request to the service.
   * @param {Authenticator} options.authenticator - The Authenticator object used to authenticate requests to the service
   * @constructor
   * @returns {EventNotificationsV1}
   */
  constructor(options: UserOptions) {
    options = options || {};

    super(options);
    if (options.serviceUrl) {
      this.setServiceUrl(options.serviceUrl);
    } else {
      this.setServiceUrl(EventNotificationsV1.DEFAULT_SERVICE_URL);
    }
  }

  /*************************
   * metrics
   ************************/

  /**
   * Get metrics.
   *
   * Get metrics.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.destinationType - Destination type. Allowed values are [smtp_custom].
   * @param {string} params.gte - GTE (greater than equal), start timestamp in UTC.
   * @param {string} params.lte - LTE (less than equal), end timestamp in UTC.
   * @param {string} [params.destinationId] - Unique identifier for Destination.
   * @param {string} [params.sourceId] - Unique identifier for Source.
   * @param {string} [params.emailTo] - Receiver email id.
   * @param {string} [params.notificationId] - Notification Id.
   * @param {string} [params.subject] - Email subject.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.Metrics>>}
   */
  public getMetrics(
    params: EventNotificationsV1.GetMetricsParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.Metrics>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'destinationType', 'gte', 'lte'];
    const _validParams = [
      'instanceId',
      'destinationType',
      'gte',
      'lte',
      'destinationId',
      'sourceId',
      'emailTo',
      'notificationId',
      'subject',
      'headers',
    ];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'destination_type': _params.destinationType,
      'gte': _params.gte,
      'lte': _params.lte,
      'destination_id': _params.destinationId,
      'source_id': _params.sourceId,
      'email_to': _params.emailTo,
      'notification_id': _params.notificationId,
      'subject': _params.subject,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(EventNotificationsV1.DEFAULT_SERVICE_NAME, 'v1', 'getMetrics');

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/metrics',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * sendNotifications
   ************************/

  /**
   * Send a notification.
   *
   * Send Notifications body from the instance. For more information about Event Notifications payload, see
   * [here](https://cloud.ibm.com/docs/event-notifications?topic=event-notifications-en-spec-payload).
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {NotificationCreate} [params.body] -
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.NotificationResponse>>}
   */
  public sendNotifications(
    params: EventNotificationsV1.SendNotificationsParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.NotificationResponse>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'body', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = _params.body;
    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'sendNotifications'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/notifications',
        method: 'POST',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * sources
   ************************/

  /**
   * Create a new API Source.
   *
   * Create a new API Source.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.name - Name of the source.
   * @param {string} params.description - Description of the source.
   * @param {boolean} [params.enabled] - Whether the source is enabled or not.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.SourceResponse>>}
   */
  public createSources(
    params: EventNotificationsV1.CreateSourcesParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.SourceResponse>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'name', 'description'];
    const _validParams = ['instanceId', 'name', 'description', 'enabled', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'description': _params.description,
      'enabled': _params.enabled,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createSources'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/sources',
        method: 'POST',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all Sources.
   *
   * List all Sources.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {number} [params.limit] - Page limit for paginated results.
   * @param {number} [params.offset] - offset for paginated results.
   * @param {string} [params.search] - Search string for filtering results.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.SourceList>>}
   */
  public listSources(
    params: EventNotificationsV1.ListSourcesParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.SourceList>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'limit', 'offset', 'search', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'limit': _params.limit,
      'offset': _params.offset,
      'search': _params.search,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listSources'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/sources',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Get a Source.
   *
   * Get a Source.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Source.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.Source>>}
   */
  public getSource(
    params: EventNotificationsV1.GetSourceParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.Source>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(EventNotificationsV1.DEFAULT_SERVICE_NAME, 'v1', 'getSource');

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/sources/{id}',
        method: 'GET',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a Source.
   *
   * Delete a Source.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Source.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>>}
   */
  public deleteSource(
    params: EventNotificationsV1.DeleteSourceParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteSource'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/sources/{id}',
        method: 'DELETE',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(true, sdkHeaders, {}, _params.headers),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update details of a Source.
   *
   * Update details of a Source.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Source.
   * @param {string} [params.name] - Name of the source.
   * @param {string} [params.description] - Description of the source.
   * @param {boolean} [params.enabled] - Whether the source is enabled or not.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.Source>>}
   */
  public updateSource(
    params: EventNotificationsV1.UpdateSourceParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.Source>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'name', 'description', 'enabled', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'description': _params.description,
      'enabled': _params.enabled,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateSource'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/sources/{id}',
        method: 'PATCH',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * topics
   ************************/

  /**
   * Create a new Topic.
   *
   * Create a new Topic.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.name - Name of the topic.
   * @param {string} [params.description] - Description of the topic.
   * @param {SourcesItems[]} [params.sources] - List of sources.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.TopicResponse>>}
   */
  public createTopic(
    params: EventNotificationsV1.CreateTopicParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.TopicResponse>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'name'];
    const _validParams = ['instanceId', 'name', 'description', 'sources', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'description': _params.description,
      'sources': _params.sources,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createTopic'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/topics',
        method: 'POST',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all Topics.
   *
   * List all Topics.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {number} [params.limit] - Page limit for paginated results.
   * @param {number} [params.offset] - offset for paginated results.
   * @param {string} [params.search] - Search string for filtering results.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.TopicList>>}
   */
  public listTopics(
    params: EventNotificationsV1.ListTopicsParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.TopicList>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'limit', 'offset', 'search', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'limit': _params.limit,
      'offset': _params.offset,
      'search': _params.search,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(EventNotificationsV1.DEFAULT_SERVICE_NAME, 'v1', 'listTopics');

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/topics',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Get details of a Topic.
   *
   * Get details of a Topic.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Topic.
   * @param {string} [params.include] - Include sub topics.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.Topic>>}
   */
  public getTopic(
    params: EventNotificationsV1.GetTopicParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.Topic>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'include', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'include': _params.include,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(EventNotificationsV1.DEFAULT_SERVICE_NAME, 'v1', 'getTopic');

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/topics/{id}',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update details of a Topic.
   *
   * Update details of a Topic.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Topic.
   * @param {string} [params.name] - Name of the topic.
   * @param {string} [params.description] - Description of the topic.
   * @param {SourcesItems[]} [params.sources] - List of sources.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.Topic>>}
   */
  public replaceTopic(
    params: EventNotificationsV1.ReplaceTopicParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.Topic>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'name', 'description', 'sources', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'description': _params.description,
      'sources': _params.sources,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'replaceTopic'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/topics/{id}',
        method: 'PUT',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a Topic.
   *
   * Delete a Topic.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Topic.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>>}
   */
  public deleteTopic(
    params: EventNotificationsV1.DeleteTopicParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteTopic'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/topics/{id}',
        method: 'DELETE',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(true, sdkHeaders, {}, _params.headers),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * templates
   ************************/

  /**
   * Create a new Template.
   *
   * Create a new Template.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.name - The Message Template.
   * @param {string} params.type - The type of template.
   * @param {TemplateConfigOneOf} params.params -
   * @param {string} [params.description] - The Template description.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.TemplateResponse>>}
   */
  public createTemplate(
    params: EventNotificationsV1.CreateTemplateParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.TemplateResponse>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'name', 'type', 'params'];
    const _validParams = ['instanceId', 'name', 'type', 'params', 'description', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'type': _params.type,
      'params': _params.params,
      'description': _params.description,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createTemplate'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/templates',
        method: 'POST',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all templates.
   *
   * List all Templates.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {number} [params.limit] - Page limit for paginated results.
   * @param {number} [params.offset] - offset for paginated results.
   * @param {string} [params.search] - Search string for filtering results.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.TemplateList>>}
   */
  public listTemplates(
    params: EventNotificationsV1.ListTemplatesParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.TemplateList>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'limit', 'offset', 'search', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'limit': _params.limit,
      'offset': _params.offset,
      'search': _params.search,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listTemplates'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/templates',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Get details of a Template.
   *
   * Get details of a Template.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Template.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.Template>>}
   */
  public getTemplate(
    params: EventNotificationsV1.GetTemplateParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.Template>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getTemplate'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/templates/{id}',
        method: 'GET',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update details of a Template.
   *
   * Update details of a Template.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Template.
   * @param {string} [params.name] - Template name.
   * @param {string} [params.description] - Template description.
   * @param {string} [params.type] - The type of template.
   * @param {TemplateConfigOneOf} [params.params] -
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.Template>>}
   */
  public replaceTemplate(
    params: EventNotificationsV1.ReplaceTemplateParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.Template>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'name', 'description', 'type', 'params', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'description': _params.description,
      'type': _params.type,
      'params': _params.params,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'replaceTemplate'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/templates/{id}',
        method: 'PUT',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a Template.
   *
   * Delete a Template.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Template.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>>}
   */
  public deleteTemplate(
    params: EventNotificationsV1.DeleteTemplateParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteTemplate'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/templates/{id}',
        method: 'DELETE',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(true, sdkHeaders, {}, _params.headers),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * destinations
   ************************/

  /**
   * Create a new Destination.
   *
   * Create a new Destination.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.name - The Destination name.
   * @param {string} params.type - The type of Destination Webhook.
   * @param {string} [params.description] - The Destination description.
   * @param {boolean} [params.collectFailedEvents] - Whether to collect the failed event in Cloud Object Storage bucket.
   * @param {DestinationConfig} [params.config] - Payload describing a destination configuration.
   * @param {NodeJS.ReadableStream | Buffer} [params.certificate] - Certificate for APNS.
   * @param {string} [params.certificateContentType] - The content type of certificate.
   * @param {NodeJS.ReadableStream | Buffer} [params.icon16x16] - Safari icon 16x16.
   * @param {string} [params.icon16x16ContentType] - The content type of icon16x16.
   * @param {NodeJS.ReadableStream | Buffer} [params.icon16x162x] - Safari icon 16x16@2x.
   * @param {string} [params.icon16x162xContentType] - The content type of icon16x162x.
   * @param {NodeJS.ReadableStream | Buffer} [params.icon32x32] - Safari icon 32x32.
   * @param {string} [params.icon32x32ContentType] - The content type of icon32x32.
   * @param {NodeJS.ReadableStream | Buffer} [params.icon32x322x] - Safari icon 32x32@2x.
   * @param {string} [params.icon32x322xContentType] - The content type of icon32x322x.
   * @param {NodeJS.ReadableStream | Buffer} [params.icon128x128] - Safari icon 128x128.
   * @param {string} [params.icon128x128ContentType] - The content type of icon128x128.
   * @param {NodeJS.ReadableStream | Buffer} [params.icon128x1282x] - Safari icon 128x128@2x.
   * @param {string} [params.icon128x1282xContentType] - The content type of icon128x1282x.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.DestinationResponse>>}
   */
  public createDestination(
    params: EventNotificationsV1.CreateDestinationParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.DestinationResponse>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'name', 'type'];
    const _validParams = [
      'instanceId',
      'name',
      'type',
      'description',
      'collectFailedEvents',
      'config',
      'certificate',
      'certificateContentType',
      'icon16x16',
      'icon16x16ContentType',
      'icon16x162x',
      'icon16x162xContentType',
      'icon32x32',
      'icon32x32ContentType',
      'icon32x322x',
      'icon32x322xContentType',
      'icon128x128',
      'icon128x128ContentType',
      'icon128x1282x',
      'icon128x1282xContentType',
      'headers',
    ];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const formData = {
      'name': _params.name,
      'type': _params.type,
      'description': _params.description,
      'collect_failed_events': _params.collectFailedEvents,
      'config': _params.config,
      'certificate': {
        data: _params.certificate,
        contentType: _params.certificateContentType,
      },
      'icon_16x16': {
        data: _params.icon16x16,
        contentType: _params.icon16x16ContentType,
      },
      'icon_16x16_2x': {
        data: _params.icon16x162x,
        contentType: _params.icon16x162xContentType,
      },
      'icon_32x32': {
        data: _params.icon32x32,
        contentType: _params.icon32x32ContentType,
      },
      'icon_32x32_2x': {
        data: _params.icon32x322x,
        contentType: _params.icon32x322xContentType,
      },
      'icon_128x128': {
        data: _params.icon128x128,
        contentType: _params.icon128x128ContentType,
      },
      'icon_128x128_2x': {
        data: _params.icon128x1282x,
        contentType: _params.icon128x1282xContentType,
      },
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createDestination'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/destinations',
        method: 'POST',
        path,
        formData,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'multipart/form-data',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all Destinations.
   *
   * List all Destinations.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {number} [params.limit] - Page limit for paginated results.
   * @param {number} [params.offset] - offset for paginated results.
   * @param {string} [params.search] - Search string for filtering results.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.DestinationList>>}
   */
  public listDestinations(
    params: EventNotificationsV1.ListDestinationsParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.DestinationList>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'limit', 'offset', 'search', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'limit': _params.limit,
      'offset': _params.offset,
      'search': _params.search,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listDestinations'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/destinations',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Get details of a Destination.
   *
   * Get details of a Destination.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Destination.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.Destination>>}
   */
  public getDestination(
    params: EventNotificationsV1.GetDestinationParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.Destination>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getDestination'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/destinations/{id}',
        method: 'GET',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update details of a Destination.
   *
   * Update details of a Destination.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Destination.
   * @param {string} [params.name] - Destination name.
   * @param {string} [params.description] - Destination description.
   * @param {boolean} [params.collectFailedEvents] - Whether to collect the failed event in Cloud Object Storage bucket.
   * @param {DestinationConfig} [params.config] - Payload describing a destination configuration.
   * @param {NodeJS.ReadableStream | Buffer} [params.certificate] - Certificate for APNS.
   * @param {string} [params.certificateContentType] - The content type of certificate.
   * @param {NodeJS.ReadableStream | Buffer} [params.icon16x16] - Safari icon 16x16.
   * @param {string} [params.icon16x16ContentType] - The content type of icon16x16.
   * @param {NodeJS.ReadableStream | Buffer} [params.icon16x162x] - Safari icon 16x16@2x.
   * @param {string} [params.icon16x162xContentType] - The content type of icon16x162x.
   * @param {NodeJS.ReadableStream | Buffer} [params.icon32x32] - Safari icon 32x32.
   * @param {string} [params.icon32x32ContentType] - The content type of icon32x32.
   * @param {NodeJS.ReadableStream | Buffer} [params.icon32x322x] - Safari icon 32x32@2x.
   * @param {string} [params.icon32x322xContentType] - The content type of icon32x322x.
   * @param {NodeJS.ReadableStream | Buffer} [params.icon128x128] - Safari icon 128x128.
   * @param {string} [params.icon128x128ContentType] - The content type of icon128x128.
   * @param {NodeJS.ReadableStream | Buffer} [params.icon128x1282x] - Safari icon 128x128@2x.
   * @param {string} [params.icon128x1282xContentType] - The content type of icon128x1282x.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.Destination>>}
   */
  public updateDestination(
    params: EventNotificationsV1.UpdateDestinationParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.Destination>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = [
      'instanceId',
      'id',
      'name',
      'description',
      'collectFailedEvents',
      'config',
      'certificate',
      'certificateContentType',
      'icon16x16',
      'icon16x16ContentType',
      'icon16x162x',
      'icon16x162xContentType',
      'icon32x32',
      'icon32x32ContentType',
      'icon32x322x',
      'icon32x322xContentType',
      'icon128x128',
      'icon128x128ContentType',
      'icon128x1282x',
      'icon128x1282xContentType',
      'headers',
    ];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const formData = {
      'name': _params.name,
      'description': _params.description,
      'collect_failed_events': _params.collectFailedEvents,
      'config': _params.config,
      'certificate': {
        data: _params.certificate,
        contentType: _params.certificateContentType,
      },
      'icon_16x16': {
        data: _params.icon16x16,
        contentType: _params.icon16x16ContentType,
      },
      'icon_16x16_2x': {
        data: _params.icon16x162x,
        contentType: _params.icon16x162xContentType,
      },
      'icon_32x32': {
        data: _params.icon32x32,
        contentType: _params.icon32x32ContentType,
      },
      'icon_32x32_2x': {
        data: _params.icon32x322x,
        contentType: _params.icon32x322xContentType,
      },
      'icon_128x128': {
        data: _params.icon128x128,
        contentType: _params.icon128x128ContentType,
      },
      'icon_128x128_2x': {
        data: _params.icon128x1282x,
        contentType: _params.icon128x1282xContentType,
      },
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateDestination'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/destinations/{id}',
        method: 'PATCH',
        path,
        formData,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'multipart/form-data',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a Destination.
   *
   * Delete a Destination.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Destination.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>>}
   */
  public deleteDestination(
    params: EventNotificationsV1.DeleteDestinationParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteDestination'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/destinations/{id}',
        method: 'DELETE',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(true, sdkHeaders, {}, _params.headers),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Get enabled country details of SMS destination.
   *
   * Get enabled country details of SMS destination.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Destination.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.EnabledCountriesResponse>>}
   */
  public getEnabledCountries(
    params: EventNotificationsV1.GetEnabledCountriesParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.EnabledCountriesResponse>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getEnabledCountries'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/destinations/{id}/enabled_countries',
        method: 'GET',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Test a Destination.
   *
   * Test a Destination.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Destination.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.TestDestinationResponse>>}
   */
  public testDestination(
    params: EventNotificationsV1.TestDestinationParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.TestDestinationResponse>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'testDestination'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/destinations/{id}/test',
        method: 'POST',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Verify SPF and DKIM records of custom domain.
   *
   * Verify SPF and DKIM records of custom domain.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Destination.
   * @param {string} params.type - Verification type.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.VerificationResponse>>}
   */
  public updateVerifyDestination(
    params: EventNotificationsV1.UpdateVerifyDestinationParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.VerificationResponse>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id', 'type'];
    const _validParams = ['instanceId', 'id', 'type', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'type': _params.type,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateVerifyDestination'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/destinations/{id}/verify',
        method: 'PATCH',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * pushDestinationAPIs
   ************************/

  /**
   * Create a new tag subscription.
   *
   * Create a new tag subscription.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Destination.
   * @param {string} params.deviceId - Unique identifier of the device.
   * @param {string} params.tagName - The name of the tag its subscribed.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.DestinationTagsSubscriptionResponse>>}
   */
  public createTagsSubscription(
    params: EventNotificationsV1.CreateTagsSubscriptionParams
  ): Promise<
    EventNotificationsV1.Response<EventNotificationsV1.DestinationTagsSubscriptionResponse>
  > {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id', 'deviceId', 'tagName'];
    const _validParams = ['instanceId', 'id', 'deviceId', 'tagName', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'device_id': _params.deviceId,
      'tag_name': _params.tagName,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createTagsSubscription'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions',
        method: 'POST',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all tag subscriptions.
   *
   * List all tag subscriptions.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Destination.
   * @param {string} [params.deviceId] - Device ID of the destination tagsubscription.
   * @param {string} [params.userId] - UserID of the destination.
   * @param {string} [params.tagName] - TagName of the subscription.
   * @param {number} [params.limit] - Page limit for paginated results.
   * @param {number} [params.offset] - offset for paginated results.
   * @param {string} [params.search] - Search string for filtering results.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.TagsSubscriptionList>>}
   */
  public listTagsSubscription(
    params: EventNotificationsV1.ListTagsSubscriptionParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.TagsSubscriptionList>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = [
      'instanceId',
      'id',
      'deviceId',
      'userId',
      'tagName',
      'limit',
      'offset',
      'search',
      'headers',
    ];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'device_id': _params.deviceId,
      'user_id': _params.userId,
      'tag_name': _params.tagName,
      'limit': _params.limit,
      'offset': _params.offset,
      'search': _params.search,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listTagsSubscription'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a tag subscription.
   *
   * Delete a tag subscription.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Destination.
   * @param {string} [params.deviceId] - Device ID of the destination tagsubscription.
   * @param {string} [params.tagName] - TagName of the subscription.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>>}
   */
  public deleteTagsSubscription(
    params: EventNotificationsV1.DeleteTagsSubscriptionParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'deviceId', 'tagName', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'device_id': _params.deviceId,
      'tag_name': _params.tagName,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteTagsSubscription'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions',
        method: 'DELETE',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(true, sdkHeaders, {}, _params.headers),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * subscriptions
   ************************/

  /**
   * Create a new Subscription.
   *
   * Create a new Subscription.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.name - Subscription name.
   * @param {string} params.destinationId - Destination ID.
   * @param {string} params.topicId - Topic ID.
   * @param {string} [params.description] - Subscription description.
   * @param {SubscriptionCreateAttributes} [params.attributes] -
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.Subscription>>}
   */
  public createSubscription(
    params: EventNotificationsV1.CreateSubscriptionParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.Subscription>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'name', 'destinationId', 'topicId'];
    const _validParams = [
      'instanceId',
      'name',
      'destinationId',
      'topicId',
      'description',
      'attributes',
      'headers',
    ];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'destination_id': _params.destinationId,
      'topic_id': _params.topicId,
      'description': _params.description,
      'attributes': _params.attributes,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createSubscription'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/subscriptions',
        method: 'POST',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all Subscriptions.
   *
   * List all Subscriptions.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {number} [params.offset] - offset for paginated results.
   * @param {number} [params.limit] - Page limit for paginated results.
   * @param {string} [params.search] - Search string for filtering results.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.SubscriptionList>>}
   */
  public listSubscriptions(
    params: EventNotificationsV1.ListSubscriptionsParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.SubscriptionList>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'offset', 'limit', 'search', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'offset': _params.offset,
      'limit': _params.limit,
      'search': _params.search,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listSubscriptions'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/subscriptions',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Get details of a Subscription.
   *
   * Get details of a Subscription.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Subscription.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.Subscription>>}
   */
  public getSubscription(
    params: EventNotificationsV1.GetSubscriptionParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.Subscription>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getSubscription'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/subscriptions/{id}',
        method: 'GET',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a Subscription.
   *
   * Delete a Subscription.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Subscription.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>>}
   */
  public deleteSubscription(
    params: EventNotificationsV1.DeleteSubscriptionParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteSubscription'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/subscriptions/{id}',
        method: 'DELETE',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(true, sdkHeaders, {}, _params.headers),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update details of a Subscription.
   *
   * Update details of a Subscription.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for Subscription.
   * @param {string} [params.name] - Name of the subscription.
   * @param {string} [params.description] - Description of the subscription.
   * @param {SubscriptionUpdateAttributes} [params.attributes] -
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.Subscription>>}
   */
  public updateSubscription(
    params: EventNotificationsV1.UpdateSubscriptionParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.Subscription>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'name', 'description', 'attributes', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'description': _params.description,
      'attributes': _params.attributes,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateSubscription'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/subscriptions/{id}',
        method: 'PATCH',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * integrations
   ************************/

  /**
   * Create an Integration.
   *
   * Create an Integration.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.type - The type of Integration.
   * @param {IntegrationCreateMetadata} params.metadata - Integration Metadata object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.IntegrationCreateResponse>>}
   */
  public createIntegration(
    params: EventNotificationsV1.CreateIntegrationParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.IntegrationCreateResponse>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'type', 'metadata'];
    const _validParams = ['instanceId', 'type', 'metadata', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'type': _params.type,
      'metadata': _params.metadata,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createIntegration'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/integrations',
        method: 'POST',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all Integrations.
   *
   * List of all KMS Integrations.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {number} [params.offset] - offset for paginated results.
   * @param {number} [params.limit] - Page limit for paginated results.
   * @param {string} [params.search] - Search string for filtering results.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.IntegrationList>>}
   */
  public listIntegrations(
    params: EventNotificationsV1.ListIntegrationsParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.IntegrationList>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'offset', 'limit', 'search', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'offset': _params.offset,
      'limit': _params.limit,
      'search': _params.search,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listIntegrations'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/integrations',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Get a single Integration.
   *
   * Get a single KMS Integration.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for integration.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.IntegrationGetResponse>>}
   */
  public getIntegration(
    params: EventNotificationsV1.GetIntegrationParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.IntegrationGetResponse>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getIntegration'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/integrations/{id}',
        method: 'GET',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update an existing Integration.
   *
   * Update an existing Integration.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for integration.
   * @param {string} params.type - Integration type. Allowed values are kms and hs-crypto.
   * @param {IntegrationMetadata} params.metadata - Integration Metadata object.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.IntegrationGetResponse>>}
   */
  public replaceIntegration(
    params: EventNotificationsV1.ReplaceIntegrationParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.IntegrationGetResponse>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id', 'type', 'metadata'];
    const _validParams = ['instanceId', 'id', 'type', 'metadata', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'type': _params.type,
      'metadata': _params.metadata,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'replaceIntegration'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/integrations/{id}',
        method: 'PUT',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
  /*************************
   * sMTPConfigurations
   ************************/

  /**
   * Create a new SMTP Configuration.
   *
   * Create a new SMTP Configuration.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.name - The name of SMTP configuration.
   * @param {string} params.domain - Domain Name.
   * @param {string} [params.description] - The description of SMTP configuration.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPCreateResponse>>}
   */
  public createSmtpConfiguration(
    params: EventNotificationsV1.CreateSmtpConfigurationParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPCreateResponse>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'name', 'domain'];
    const _validParams = ['instanceId', 'name', 'domain', 'description', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'domain': _params.domain,
      'description': _params.description,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createSmtpConfiguration'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/smtp/config',
        method: 'POST',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all SMTP Configurations.
   *
   * List all SMTP Configurations.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {number} [params.limit] - Page limit for paginated results.
   * @param {number} [params.offset] - offset for paginated results.
   * @param {string} [params.search] - Search string for filtering results.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPConfigurationsList>>}
   */
  public listSmtpConfigurations(
    params: EventNotificationsV1.ListSmtpConfigurationsParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPConfigurationsList>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId'];
    const _validParams = ['instanceId', 'limit', 'offset', 'search', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'limit': _params.limit,
      'offset': _params.offset,
      'search': _params.search,
    };

    const path = {
      'instance_id': _params.instanceId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listSmtpConfigurations'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/smtp/config',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Create a new SMTP User.
   *
   * Create a new SMTP User.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for SMTP.
   * @param {string} [params.description] - The description of SMTP configuration.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPUserResponse>>}
   */
  public createSmtpUser(
    params: EventNotificationsV1.CreateSmtpUserParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPUserResponse>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'description', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'description': _params.description,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'createSmtpUser'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/smtp/config/{id}/users',
        method: 'POST',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * List all SMTP users.
   *
   * List all SMTP users.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for SMTP.
   * @param {number} [params.limit] - Page limit for paginated results.
   * @param {number} [params.offset] - offset for paginated results.
   * @param {string} [params.search] - Search string for filtering results.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPUsersList>>}
   */
  public listSmtpUsers(
    params: EventNotificationsV1.ListSmtpUsersParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPUsersList>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'limit', 'offset', 'search', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'limit': _params.limit,
      'offset': _params.offset,
      'search': _params.search,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'listSmtpUsers'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/smtp/config/{id}/users',
        method: 'GET',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Get details of a SMTP Configuration.
   *
   * Get details of a SMTP Configuration.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for SMTP.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPConfiguration>>}
   */
  public getSmtpConfiguration(
    params: EventNotificationsV1.GetSmtpConfigurationParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPConfiguration>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getSmtpConfiguration'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/smtp/config/{id}',
        method: 'GET',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update details of SMTP Configuration.
   *
   * Update details of SMTP Configuration.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for SMTP.
   * @param {string} [params.name] - SMTP name.
   * @param {string} [params.description] - SMTP description.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPConfiguration>>}
   */
  public updateSmtpConfiguration(
    params: EventNotificationsV1.UpdateSmtpConfigurationParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPConfiguration>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'name', 'description', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'name': _params.name,
      'description': _params.description,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateSmtpConfiguration'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/smtp/config/{id}',
        method: 'PATCH',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a SMTP Configuration.
   *
   * Delete a SMTP Configuration.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for SMTP.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>>}
   */
  public deleteSmtpConfiguration(
    params: EventNotificationsV1.DeleteSmtpConfigurationParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteSmtpConfiguration'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/smtp/config/{id}',
        method: 'DELETE',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(true, sdkHeaders, {}, _params.headers),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Get details of a SMTP User.
   *
   * Get details of a SMTP User.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for SMTP.
   * @param {string} params.userId - UserID.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPUser>>}
   */
  public getSmtpUser(
    params: EventNotificationsV1.GetSmtpUserParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPUser>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id', 'userId'];
    const _validParams = ['instanceId', 'id', 'userId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
      'user_id': _params.userId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getSmtpUser'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/smtp/config/{id}/users/{user_id}',
        method: 'GET',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Update details of a SMTP User.
   *
   * Update details of a SMTP User.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for SMTP.
   * @param {string} params.userId - UserID.
   * @param {string} [params.description] - SMTP user description.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPUser>>}
   */
  public updateSmtpUser(
    params: EventNotificationsV1.UpdateSmtpUserParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPUser>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id', 'userId'];
    const _validParams = ['instanceId', 'id', 'userId', 'description', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const body = {
      'description': _params.description,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
      'user_id': _params.userId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateSmtpUser'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/smtp/config/{id}/users/{user_id}',
        method: 'PATCH',
        body,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Delete a SMTP user.
   *
   * Delete a SMTP user.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for SMTP.
   * @param {string} params.userId - UserID.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>>}
   */
  public deleteSmtpUser(
    params: EventNotificationsV1.DeleteSmtpUserParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.EmptyObject>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id', 'userId'];
    const _validParams = ['instanceId', 'id', 'userId', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
      'user_id': _params.userId,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'deleteSmtpUser'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/smtp/config/{id}/users/{user_id}',
        method: 'DELETE',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(true, sdkHeaders, {}, _params.headers),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Get details of SMTP configuration allowed IPs.
   *
   * Get details of SMTP configuration allowed IPs.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for SMTP.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPAllowedIPs>>}
   */
  public getSmtpAllowedIps(
    params: EventNotificationsV1.GetSmtpAllowedIpsParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPAllowedIPs>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id'];
    const _validParams = ['instanceId', 'id', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'getSmtpAllowedIps'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/smtp/config/{id}/allowed_ips',
        method: 'GET',
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }

  /**
   * Verify SMTP configuration domain.
   *
   * Verify SMTP configuration domain.
   *
   * @param {Object} params - The parameters to send to the service.
   * @param {string} params.instanceId - Unique identifier for IBM Cloud Event Notifications instance.
   * @param {string} params.id - Unique identifier for SMTP.
   * @param {string} params.type - SMTP verification type.
   * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
   * @returns {Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPVerificationUpdateResponse>>}
   */
  public updateVerifySmtp(
    params: EventNotificationsV1.UpdateVerifySmtpParams
  ): Promise<EventNotificationsV1.Response<EventNotificationsV1.SMTPVerificationUpdateResponse>> {
    const _params = { ...params };
    const _requiredParams = ['instanceId', 'id', 'type'];
    const _validParams = ['instanceId', 'id', 'type', 'headers'];
    const _validationErrors = validateParams(_params, _requiredParams, _validParams);
    if (_validationErrors) {
      return Promise.reject(_validationErrors);
    }

    const query = {
      'type': _params.type,
    };

    const path = {
      'instance_id': _params.instanceId,
      'id': _params.id,
    };

    const sdkHeaders = getSdkHeaders(
      EventNotificationsV1.DEFAULT_SERVICE_NAME,
      'v1',
      'updateVerifySmtp'
    );

    const parameters = {
      options: {
        url: '/v1/instances/{instance_id}/smtp/config/{id}/verify',
        method: 'PATCH',
        qs: query,
        path,
      },
      defaultOptions: extend(true, {}, this.baseOptions, {
        headers: extend(
          true,
          sdkHeaders,
          {
            'Accept': 'application/json',
          },
          _params.headers
        ),
      }),
    };

    return this.createRequest(parameters);
  }
}

/*************************
 * interfaces
 ************************/

namespace EventNotificationsV1 {
  /** An operation response. */
  export interface Response<T = any> {
    result: T;
    status: number;
    statusText: string;
    headers: IncomingHttpHeaders;
  }

  /** The callback for a service request. */
  export type Callback<T> = (error: any, response?: Response<T>) => void;

  /** The body of a service request that returns no response data. */
  export interface EmptyObject {}

  /** A standard JS object, defined to avoid the limitations of `Object` and `object` */
  export interface JsonObject {
    [key: string]: any;
  }

  /*************************
   * request interfaces
   ************************/

  /** Parameters for the `getMetrics` operation. */
  export interface GetMetricsParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Destination type. Allowed values are [smtp_custom]. */
    destinationType: GetMetricsConstants.DestinationType | string;
    /** GTE (greater than equal), start timestamp in UTC. */
    gte: string;
    /** LTE (less than equal), end timestamp in UTC. */
    lte: string;
    /** Unique identifier for Destination. */
    destinationId?: string;
    /** Unique identifier for Source. */
    sourceId?: string;
    /** Receiver email id. */
    emailTo?: string;
    /** Notification Id. */
    notificationId?: string;
    /** Email subject. */
    subject?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `getMetrics` operation. */
  export namespace GetMetricsConstants {
    /** Destination type. Allowed values are [smtp_custom]. */
    export enum DestinationType {
      SMTP_CUSTOM = 'smtp_custom',
    }
  }

  /** Parameters for the `sendNotifications` operation. */
  export interface SendNotificationsParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    body?: NotificationCreate;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createSources` operation. */
  export interface CreateSourcesParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Name of the source. */
    name: string;
    /** Description of the source. */
    description: string;
    /** Whether the source is enabled or not. */
    enabled?: boolean;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listSources` operation. */
  export interface ListSourcesParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Page limit for paginated results. */
    limit?: number;
    /** offset for paginated results. */
    offset?: number;
    /** Search string for filtering results. */
    search?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getSource` operation. */
  export interface GetSourceParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Source. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteSource` operation. */
  export interface DeleteSourceParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Source. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateSource` operation. */
  export interface UpdateSourceParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Source. */
    id: string;
    /** Name of the source. */
    name?: string;
    /** Description of the source. */
    description?: string;
    /** Whether the source is enabled or not. */
    enabled?: boolean;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createTopic` operation. */
  export interface CreateTopicParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Name of the topic. */
    name: string;
    /** Description of the topic. */
    description?: string;
    /** List of sources. */
    sources?: SourcesItems[];
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listTopics` operation. */
  export interface ListTopicsParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Page limit for paginated results. */
    limit?: number;
    /** offset for paginated results. */
    offset?: number;
    /** Search string for filtering results. */
    search?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getTopic` operation. */
  export interface GetTopicParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Topic. */
    id: string;
    /** Include sub topics. */
    include?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `replaceTopic` operation. */
  export interface ReplaceTopicParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Topic. */
    id: string;
    /** Name of the topic. */
    name?: string;
    /** Description of the topic. */
    description?: string;
    /** List of sources. */
    sources?: SourcesItems[];
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteTopic` operation. */
  export interface DeleteTopicParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Topic. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createTemplate` operation. */
  export interface CreateTemplateParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** The Message Template. */
    name: string;
    /** The type of template. */
    type: string;
    params: TemplateConfigOneOf;
    /** The Template description. */
    description?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listTemplates` operation. */
  export interface ListTemplatesParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Page limit for paginated results. */
    limit?: number;
    /** offset for paginated results. */
    offset?: number;
    /** Search string for filtering results. */
    search?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getTemplate` operation. */
  export interface GetTemplateParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Template. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `replaceTemplate` operation. */
  export interface ReplaceTemplateParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Template. */
    id: string;
    /** Template name. */
    name?: string;
    /** Template description. */
    description?: string;
    /** The type of template. */
    type?: string;
    params?: TemplateConfigOneOf;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteTemplate` operation. */
  export interface DeleteTemplateParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Template. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createDestination` operation. */
  export interface CreateDestinationParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** The Destination name. */
    name: string;
    /** The type of Destination Webhook. */
    type: CreateDestinationConstants.Type | string;
    /** The Destination description. */
    description?: string;
    /** Whether to collect the failed event in Cloud Object Storage bucket. */
    collectFailedEvents?: boolean;
    /** Payload describing a destination configuration. */
    config?: DestinationConfig;
    /** Certificate for APNS. */
    certificate?: NodeJS.ReadableStream | Buffer;
    /** The content type of certificate. */
    certificateContentType?: string;
    /** Safari icon 16x16. */
    icon16x16?: NodeJS.ReadableStream | Buffer;
    /** The content type of icon16x16. */
    icon16x16ContentType?: string;
    /** Safari icon 16x16@2x. */
    icon16x162x?: NodeJS.ReadableStream | Buffer;
    /** The content type of icon16x162x. */
    icon16x162xContentType?: string;
    /** Safari icon 32x32. */
    icon32x32?: NodeJS.ReadableStream | Buffer;
    /** The content type of icon32x32. */
    icon32x32ContentType?: string;
    /** Safari icon 32x32@2x. */
    icon32x322x?: NodeJS.ReadableStream | Buffer;
    /** The content type of icon32x322x. */
    icon32x322xContentType?: string;
    /** Safari icon 128x128. */
    icon128x128?: NodeJS.ReadableStream | Buffer;
    /** The content type of icon128x128. */
    icon128x128ContentType?: string;
    /** Safari icon 128x128@2x. */
    icon128x1282x?: NodeJS.ReadableStream | Buffer;
    /** The content type of icon128x1282x. */
    icon128x1282xContentType?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createDestination` operation. */
  export namespace CreateDestinationConstants {
    /** The type of Destination Webhook. */
    export enum Type {
      WEBHOOK = 'webhook',
      PUSH_ANDROID = 'push_android',
      PUSH_IOS = 'push_ios',
      PUSH_CHROME = 'push_chrome',
      PUSH_FIREFOX = 'push_firefox',
      SLACK = 'slack',
      IBMCE = 'ibmce',
      PAGERDUTY = 'pagerduty',
      PUSH_SAFARI = 'push_safari',
      MSTEAMS = 'msteams',
      SERVICENOW = 'servicenow',
      IBMCOS = 'ibmcos',
      PUSH_HUAWEI = 'push_huawei',
      SMTP_CUSTOM = 'smtp_custom',
      SMS_CUSTOM = 'sms_custom',
    }
  }

  /** Parameters for the `listDestinations` operation. */
  export interface ListDestinationsParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Page limit for paginated results. */
    limit?: number;
    /** offset for paginated results. */
    offset?: number;
    /** Search string for filtering results. */
    search?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getDestination` operation. */
  export interface GetDestinationParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Destination. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateDestination` operation. */
  export interface UpdateDestinationParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Destination. */
    id: string;
    /** Destination name. */
    name?: string;
    /** Destination description. */
    description?: string;
    /** Whether to collect the failed event in Cloud Object Storage bucket. */
    collectFailedEvents?: boolean;
    /** Payload describing a destination configuration. */
    config?: DestinationConfig;
    /** Certificate for APNS. */
    certificate?: NodeJS.ReadableStream | Buffer;
    /** The content type of certificate. */
    certificateContentType?: string;
    /** Safari icon 16x16. */
    icon16x16?: NodeJS.ReadableStream | Buffer;
    /** The content type of icon16x16. */
    icon16x16ContentType?: string;
    /** Safari icon 16x16@2x. */
    icon16x162x?: NodeJS.ReadableStream | Buffer;
    /** The content type of icon16x162x. */
    icon16x162xContentType?: string;
    /** Safari icon 32x32. */
    icon32x32?: NodeJS.ReadableStream | Buffer;
    /** The content type of icon32x32. */
    icon32x32ContentType?: string;
    /** Safari icon 32x32@2x. */
    icon32x322x?: NodeJS.ReadableStream | Buffer;
    /** The content type of icon32x322x. */
    icon32x322xContentType?: string;
    /** Safari icon 128x128. */
    icon128x128?: NodeJS.ReadableStream | Buffer;
    /** The content type of icon128x128. */
    icon128x128ContentType?: string;
    /** Safari icon 128x128@2x. */
    icon128x1282x?: NodeJS.ReadableStream | Buffer;
    /** The content type of icon128x1282x. */
    icon128x1282xContentType?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteDestination` operation. */
  export interface DeleteDestinationParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Destination. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getEnabledCountries` operation. */
  export interface GetEnabledCountriesParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Destination. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `testDestination` operation. */
  export interface TestDestinationParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Destination. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateVerifyDestination` operation. */
  export interface UpdateVerifyDestinationParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Destination. */
    id: string;
    /** Verification type. */
    type: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createTagsSubscription` operation. */
  export interface CreateTagsSubscriptionParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Destination. */
    id: string;
    /** Unique identifier of the device. */
    deviceId: string;
    /** The name of the tag its subscribed. */
    tagName: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listTagsSubscription` operation. */
  export interface ListTagsSubscriptionParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Destination. */
    id: string;
    /** Device ID of the destination tagsubscription. */
    deviceId?: string;
    /** UserID of the destination. */
    userId?: string;
    /** TagName of the subscription. */
    tagName?: string;
    /** Page limit for paginated results. */
    limit?: number;
    /** offset for paginated results. */
    offset?: number;
    /** Search string for filtering results. */
    search?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteTagsSubscription` operation. */
  export interface DeleteTagsSubscriptionParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Destination. */
    id: string;
    /** Device ID of the destination tagsubscription. */
    deviceId?: string;
    /** TagName of the subscription. */
    tagName?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createSubscription` operation. */
  export interface CreateSubscriptionParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Subscription name. */
    name: string;
    /** Destination ID. */
    destinationId: string;
    /** Topic ID. */
    topicId: string;
    /** Subscription description. */
    description?: string;
    attributes?: SubscriptionCreateAttributes;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listSubscriptions` operation. */
  export interface ListSubscriptionsParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** offset for paginated results. */
    offset?: number;
    /** Page limit for paginated results. */
    limit?: number;
    /** Search string for filtering results. */
    search?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getSubscription` operation. */
  export interface GetSubscriptionParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Subscription. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteSubscription` operation. */
  export interface DeleteSubscriptionParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Subscription. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateSubscription` operation. */
  export interface UpdateSubscriptionParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for Subscription. */
    id: string;
    /** Name of the subscription. */
    name?: string;
    /** Description of the subscription. */
    description?: string;
    attributes?: SubscriptionUpdateAttributes;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createIntegration` operation. */
  export interface CreateIntegrationParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** The type of Integration. */
    type: CreateIntegrationConstants.Type | string;
    /** Integration Metadata object. */
    metadata: IntegrationCreateMetadata;
    headers?: OutgoingHttpHeaders;
  }

  /** Constants for the `createIntegration` operation. */
  export namespace CreateIntegrationConstants {
    /** The type of Integration. */
    export enum Type {
      COLLECT_FAILED_EVENTS = 'collect_failed_events',
    }
  }

  /** Parameters for the `listIntegrations` operation. */
  export interface ListIntegrationsParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** offset for paginated results. */
    offset?: number;
    /** Page limit for paginated results. */
    limit?: number;
    /** Search string for filtering results. */
    search?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getIntegration` operation. */
  export interface GetIntegrationParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for integration. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `replaceIntegration` operation. */
  export interface ReplaceIntegrationParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for integration. */
    id: string;
    /** Integration type. Allowed values are kms and hs-crypto. */
    type: string;
    /** Integration Metadata object. */
    metadata: IntegrationMetadata;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createSmtpConfiguration` operation. */
  export interface CreateSmtpConfigurationParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** The name of SMTP configuration. */
    name: string;
    /** Domain Name. */
    domain: string;
    /** The description of SMTP configuration. */
    description?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listSmtpConfigurations` operation. */
  export interface ListSmtpConfigurationsParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Page limit for paginated results. */
    limit?: number;
    /** offset for paginated results. */
    offset?: number;
    /** Search string for filtering results. */
    search?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `createSmtpUser` operation. */
  export interface CreateSmtpUserParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for SMTP. */
    id: string;
    /** The description of SMTP configuration. */
    description?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `listSmtpUsers` operation. */
  export interface ListSmtpUsersParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for SMTP. */
    id: string;
    /** Page limit for paginated results. */
    limit?: number;
    /** offset for paginated results. */
    offset?: number;
    /** Search string for filtering results. */
    search?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getSmtpConfiguration` operation. */
  export interface GetSmtpConfigurationParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for SMTP. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateSmtpConfiguration` operation. */
  export interface UpdateSmtpConfigurationParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for SMTP. */
    id: string;
    /** SMTP name. */
    name?: string;
    /** SMTP description. */
    description?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteSmtpConfiguration` operation. */
  export interface DeleteSmtpConfigurationParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for SMTP. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getSmtpUser` operation. */
  export interface GetSmtpUserParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for SMTP. */
    id: string;
    /** UserID. */
    userId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateSmtpUser` operation. */
  export interface UpdateSmtpUserParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for SMTP. */
    id: string;
    /** UserID. */
    userId: string;
    /** SMTP user description. */
    description?: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `deleteSmtpUser` operation. */
  export interface DeleteSmtpUserParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for SMTP. */
    id: string;
    /** UserID. */
    userId: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `getSmtpAllowedIps` operation. */
  export interface GetSmtpAllowedIpsParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for SMTP. */
    id: string;
    headers?: OutgoingHttpHeaders;
  }

  /** Parameters for the `updateVerifySmtp` operation. */
  export interface UpdateVerifySmtpParams {
    /** Unique identifier for IBM Cloud Event Notifications instance. */
    instanceId: string;
    /** Unique identifier for SMTP. */
    id: string;
    /** SMTP verification type. */
    type: string;
    headers?: OutgoingHttpHeaders;
  }

  /*************************
   * model interfaces
   ************************/

  /** Bucket object. */
  export interface Buckets {
    /** Total count. */
    doc_count?: number;
    /** Timestamp. */
    key_as_string?: string;
  }

  /** Payload describing a Slack Direct Message chennel configuration. */
  export interface ChannelCreateAttributes {
    /** channel id. */
    id: string;
  }

  /** Payload describing a Slack Direct Message chennel configuration. */
  export interface ChannelUpdateAttributes {
    /** channel id. */
    id: string;
    /** The channel operation type. */
    operation: string;
  }

  /** The DKIM attributes. */
  export interface DKIMAttributes {
    /** dkim public key. */
    public_key?: string;
    /** dkim selector. */
    selector?: string;
    /** dkim verification. */
    verification?: string;
  }

  /** Payload describing a destination get request. */
  export interface Destination {
    /** Destination ID. */
    id: string;
    /** Destination name. */
    name: string;
    /** Destination description. */
    description: string;
    /** Destination type
     *  Email/SMS/Webhook/FCM/Slack/MSTeams/PagerDuty/IBMCodeEngine/ServiceNow/IBMCloudObjectStorage/Huawei.
     */
    type: string;
    /** Whether to collect the failed event in Cloud Object Storage bucket. */
    collect_failed_events?: boolean;
    /** Payload describing a destination configuration. */
    config?: DestinationConfig;
    /** Last updated time. */
    updated_at: string;
    /** Number of subscriptions. */
    subscription_count: number;
    /** List of subscriptions. */
    subscription_names: string[];
  }

  /** Payload describing a destination configuration. */
  export interface DestinationConfig {
    params: DestinationConfigOneOf;
  }

  /** DestinationConfigOneOf. */
  export interface DestinationConfigOneOf {}

  /** Payload describing a destination list request. */
  export interface DestinationList {
    /** Total number of destinations. */
    total_count: number;
    /** Current offset. */
    offset: number;
    /** limit to show destinations. */
    limit: number;
    /** List of destinations. */
    destinations: DestinationListItem[];
    /** Response having URL of the page. */
    first?: PageHrefResponse;
    /** Response having URL of the page. */
    previous?: PageHrefResponse;
    /** Response having URL of the page. */
    next?: PageHrefResponse;
  }

  /** Destination object. */
  export interface DestinationListItem {
    /** Destination ID. */
    id: string;
    /** Destination name. */
    name: string;
    /** Destination description. */
    description: string;
    /** Destination type. */
    type: string;
    /** Whether to collect the failed event in Cloud Object Storage bucket. */
    collect_failed_events?: boolean;
    /** Subscription count. */
    subscription_count: number;
    /** Names of subscriptions. */
    subscription_names: string[];
    /** Updated at. */
    updated_at: string;
  }

  /** Payload describing a destination get request. */
  export interface DestinationResponse {
    /** Destination ID. */
    id: string;
    /** Destination name. */
    name: string;
    /** Destination description. */
    description: string;
    /** Destination type. */
    type: string;
    /** Whether to collect the failed event in Cloud Object Storage bucket. */
    collect_failed_events?: boolean;
    /** Payload describing a destination configuration. */
    config: DestinationConfig;
    /** Last updated time. */
    created_at: string;
  }

  /** Payload describing a destination get request. */
  export interface DestinationTagsSubscriptionResponse {
    /** Subscription Tag ID. */
    id: string;
    /** Unique identifier of the device. */
    device_id: string;
    /** The name of the tag its subscribed. */
    tag_name: string;
    /** The user identifier for the device registration. */
    user_id?: string;
    /** Last updated time. */
    created_at: string;
  }

  /** The en_authorization attributes. */
  export interface ENAuthAttributes {
    /** en_authorization verification. */
    verification?: string;
  }

  /** EmailAttributesResponseInvitedItems. */
  export interface EmailAttributesResponseInvitedItems {
    /** email address. */
    email?: string;
    /** last updated time. */
    updated_at?: string;
    /** time of expiration. */
    expires_at?: string;
  }

  /** EmailAttributesResponseSubscribedUnsubscribedItems. */
  export interface EmailAttributesResponseSubscribedUnsubscribedItems {
    /** email address. */
    email?: string;
    /** last updated time. */
    updated_at?: string;
  }

  /** Payload describing a custom SMS Configuration. */
  export interface EnabledCountriesResponse {
    /** The SMS destination status. */
    status: string;
    /** List enabled countries. */
    enabled_countries: SMSCountryConfig[];
  }

  /** Payload describing histogram. */
  export interface Histrogram {
    /** List of buckets. */
    buckets?: Buckets[];
  }

  /** Integration Metadata object. */
  export interface IntegrationCreateMetadata {
    /** URL for Cloud Object storage. */
    endpoint: string;
    /** CRN of the Cloud Object Storage instance. */
    crn: string;
    /** Cloud Object Storage bucket name. */
    bucket_name: string;
  }

  /** Integration create response object. */
  export interface IntegrationCreateResponse {
    /** ID of the integration. */
    id: string;
    /** Integration type. Allowed values collect_failed_events. */
    type: string;
    /** Integration Metadata object. */
    metadata: IntegrationCreateMetadata;
    /** Creation time of an integration. */
    created_at: string;
  }

  /** Integration response object. */
  export interface IntegrationGetResponse {
    /** ID of the integration. */
    id: string;
    /** Integration type. Allowed values are kms and hs-crypto. */
    type: string;
    /** Integration Metadata object. */
    metadata: IntegrationMetadata;
    /** Creation time of an integration. */
    created_at: string;
    /** Last update time of an integration. */
    updated_at: string;
  }

  /** all Integrations response object. */
  export interface IntegrationList {
    /** Number of integrations. */
    total_count: number;
    /** Current offset. */
    offset: number;
    /** limit to show integrations. */
    limit: number;
    /** List of integrations. */
    integrations: IntegrationListItem[];
    /** Response having URL of the page. */
    first?: PageHrefResponse;
    /** Response having URL of the page. */
    previous?: PageHrefResponse;
    /** Response having URL of the page. */
    next?: PageHrefResponse;
  }

  /** all Integrations response object. */
  export interface IntegrationListItem {
    /** ID of the integration. */
    id: string;
    /** Integration type. Allowed values are kms and hs-crypto. */
    type: string;
    /** Integration Metadata object. */
    metadata: IntegrationMetadata;
    /** Creation time of an integration. */
    created_at: string;
    /** Update time of an integration. */
    updated_at: string;
  }

  /** Integration Metadata object. */
  export interface IntegrationMetadata {
    /** KMS url for key management or url for COS bucket. */
    endpoint: string;
    /** CRN of the KMS/COS instance. */
    crn: string;
    /** Root Key ID of KMS. */
    root_key_id?: string;
    /** cloud object storage bucket name. */
    bucket_name?: string;
  }

  /** Payload describing metrics request. */
  export interface Metric {
    /** key. */
    key?: string;
    /** doc count. */
    doc_count?: number;
    /** Payload describing histogram. */
    histogram?: Histrogram;
  }

  /** Payload describing a metrics. */
  export interface Metrics {
    /** array of metrics. */
    metrics: Metric[];
  }

  /** Payload describing a notification create request. */
  export interface NotificationCreate {
    /** The version of the notification specification. */
    specversion: string;
    /** The time notification was created. */
    time?: string;
    /** The unique identifier of the notification. */
    id: string;
    /** The source of notifications. */
    source: string;
    /** The notifications type. */
    type: string;
    /** The severity of the notification. */
    ibmenseverity?: string;
    /** The source id of the notification. */
    ibmensourceid: string;
    /** Default short text for the message. */
    ibmendefaultshort: string;
    /** Default long text for the message. */
    ibmendefaultlong: string;
    /** The subject of the notification. */
    ibmensubject?: string;
    /** The template id Array of string. */
    ibmentemplates?: string;
    /** The email id string. */
    ibmenmailto?: string;
    /** The slack channel id/member id stringified array. */
    ibmenslackto?: string;
    /** The SMS number string. */
    ibmensmsto?: string;
    /** The html body of notification. */
    ibmenhtmlbody?: string;
    /** The subject of the notification. */
    subject?: string;
    /** Stringified MMS Attachment JSON. */
    ibmenmms?: string;
    /** The payload for webhook notification. */
    data?: JsonObject;
    /** The notification content type. */
    datacontenttype?: string;
    /** If platforms or tags or user_ids is used then do not use fcm_devices / apns_devices / chrome_devices /
     *  firefox_devices / safari_devices with it. Value should be stringified.
     */
    ibmenpushto?: string;
    /** Payload describing a notification FCM body. Value should be stringified. */
    ibmenfcmbody?: string;
    /** Payload describing a notification APNs body. Value should be stringified. */
    ibmenapnsbody?: string;
    /** Headers for iOS notification. Value should be stringified. */
    ibmenapnsheaders?: string;
    /** Notification payload for Chrome. Value should be stringified. */
    ibmenchromebody?: string;
    /** Headers for a Chrome notification. Value should be stringified. */
    ibmenchromeheaders?: string;
    /** Notification payload for Firefox. Value should be stringified. */
    ibmenfirefoxbody?: string;
    /** Headers for a Firefox notification. Value should be stringified. */
    ibmenfirefoxheaders?: string;
    /** Payload describing a notification Huawei body. Value should be stringified. */
    ibmenhuaweibody?: string;
    /** Payload describing a notification Safari body. Value should be stringified. */
    ibmensafaribody?: string;
    /** NotificationCreate accepts additional properties. */
    [propName: string]: any;
  }

  /** Payload describing a notifications response. */
  export interface NotificationResponse {
    /** Notification ID. */
    notification_id?: string;
  }

  /** Response having URL of the page. */
  export interface PageHrefResponse {
    /** URL to the page. */
    href: string;
  }

  /** Rule object. */
  export interface Rules {
    /** Whether the rule is enabled or not. */
    enabled?: boolean;
    /** Event type filter. */
    event_type_filter: string;
    /** Notification filter. */
    notification_filter?: string;
  }

  /** Rule object. */
  export interface RulesGet {
    /** Whether the rule is enabled or not. */
    enabled: boolean;
    /** Event type filter. */
    event_type_filter: string;
    /** Notification filter. */
    notification_filter: string;
    /** Last time the topic was updated. */
    updated_at: string;
    /** Autogenerated rule ID. */
    id: string;
  }

  /** The sms attributes. */
  export interface SMSAttributesItems {
    /** Phone number. */
    phone_number?: string;
    /** last updated time. */
    updated_at?: string;
  }

  /** Payload describing a country Configuration. */
  export interface SMSCountryConfig {
    /** Phone number. */
    number: string;
    /** List of Countries. */
    country: string[];
  }

  /** The sms attributes. */
  export interface SMSInviteAttributesItems {
    /** Phone number. */
    phone_number?: string;
    /** last updated time. */
    updated_at?: string;
    /** time of expiration. */
    expires_at?: string;
  }

  /** Payload describing a SMTP allowed Ips. */
  export interface SMTPAllowedIPs {
    /** The SMTP allowed Ips. */
    subnets: string[];
    /** Updated at. */
    updated_at: string;
  }

  /** Payload describing a SMTP configuration. */
  export interface SMTPConfig {
    /** The SMTP DKIM attributes. */
    dkim?: SMTPDKIMAttributes;
    /** The en_authorization attributes. */
    en_authorization?: ENAuthAttributes;
    /** The SPF attributes. */
    spf?: SPFAttributes;
  }

  /** Payload describing a SMTP List response. */
  export interface SMTPConfiguration {
    /** SMTP ID. */
    id: string;
    /** SMTP name. */
    name: string;
    /** SMTP description. */
    description?: string;
    /** Domain Name. */
    domain: string;
    /** Payload describing a SMTP configuration. */
    config: SMTPConfig;
    /** Created time. */
    updated_at: string;
  }

  /** Payload describing a SMTP Configurations list. */
  export interface SMTPConfigurationsList {
    /** Total number of SMTP configurations. */
    total_count: number;
    /** Current offset. */
    offset: number;
    /** limit to show configurations. */
    limit: number;
    /** List of SMTP Configurations. */
    smtp_configurations: SMTPConfiguration[];
    /** Response having URL of the page. */
    first?: PageHrefResponse;
    /** Response having URL of the page. */
    previous?: PageHrefResponse;
    /** Response having URL of the page. */
    next?: PageHrefResponse;
  }

  /** Payload describing a SMTP create response. */
  export interface SMTPCreateResponse {
    /** SMTP ID. */
    id: string;
    /** SMTP name. */
    name: string;
    /** SMTP description. */
    description?: string;
    /** Domain Name. */
    domain: string;
    /** Payload describing a SMTP configuration. */
    config: SMTPConfig;
    /** Created time. */
    created_at: string;
  }

  /** The SMTP DKIM attributes. */
  export interface SMTPDKIMAttributes {
    /** DKIM text name. */
    txt_name?: string;
    /** DKIM text value. */
    txt_value?: string;
    /** DKIM verification. */
    verification?: string;
  }

  /** Payload describing a SMTP User. */
  export interface SMTPUser {
    /** Id. */
    id: string;
    /** SMTP confg Id. */
    smtp_config_id: string;
    /** SMTP User description. */
    description: string;
    /** Domain Name. */
    domain: string;
    /** SMTP user name. */
    username: string;
    /** Updated time. */
    created_at: string;
    /** Updated time. */
    updated_at: string;
  }

  /** Payload describing a SMTP User create response. */
  export interface SMTPUserResponse {
    /** SMTP Id. */
    id: string;
    /** SMTP User description. */
    description?: string;
    /** Domain Name. */
    domain?: string;
    /** SMTP confg Id. */
    smtp_config_id: string;
    /** SMTP user name. */
    username: string;
    /** password. */
    password: string;
    /** Created time. */
    created_at: string;
  }

  /** Payload describing a SMTP users list request. */
  export interface SMTPUsersList {
    /** Total number of destinations. */
    total_count: number;
    /** Current offset. */
    offset: number;
    /** limit to show destinations. */
    limit: number;
    /** List of users. */
    users: SMTPUser[];
    /** Response having URL of the page. */
    first?: PageHrefResponse;
    /** Response having URL of the page. */
    previous?: PageHrefResponse;
    /** Response having URL of the page. */
    next?: PageHrefResponse;
  }

  /** verification object. */
  export interface SMTPVerificationResponse {
    /** verification type. */
    type: string;
    /** verification status. */
    verification: string;
  }

  /** Payload describing SMTP verification response. */
  export interface SMTPVerificationUpdateResponse {
    /** SMTP verification status. */
    status: SMTPVerificationResponse[];
  }

  /** The SPF attributes. */
  export interface SPFAttributes {
    /** spf text name. */
    txt_name?: string;
    /** spf text value. */
    txt_value?: string;
    /** spf verification. */
    verification?: string;
  }

  /** Payload describing a source generate request. */
  export interface Source {
    /** The id of the source. */
    id: string;
    /** The name of the source. */
    name: string;
    /** The description of the source. */
    description: string;
    /** The status of the source. */
    enabled: boolean;
    /** Type of the source. */
    type: string;
    /** The last updated time of the source. */
    updated_at: string;
    /** The number of topics. */
    topic_count: number;
    /** The names of the topics. */
    topic_names: string[];
  }

  /** Payload describing a source list request. */
  export interface SourceList {
    /** Number of sources. */
    total_count: number;
    /** Current offset. */
    offset: number;
    /** limit to show sources. */
    limit: number;
    /** List of sources. */
    sources: SourceListItem[];
    /** Response having URL of the page. */
    first?: PageHrefResponse;
    /** Response having URL of the page. */
    previous?: PageHrefResponse;
    /** Response having URL of the page. */
    next?: PageHrefResponse;
  }

  /** Payload describing a source list item. */
  export interface SourceListItem {
    /** ID of the source. */
    id: string;
    /** Name of the source. */
    name: string;
    /** Description of the source. */
    description: string;
    /** Type of the source. */
    type: string;
    /** Whether the source is enabled or not. */
    enabled: boolean;
    /** Time of the last update. */
    updated_at: string;
    /** Number of topics. */
    topic_count: number;
  }

  /** Payload describing a source. */
  export interface SourceResponse {
    /** ID of the source. */
    id: string;
    /** Name of the source. */
    name: string;
    /** Description of the source. */
    description: string;
    /** Whether the source is enabled or not. */
    enabled: boolean;
    /** Time of the created. */
    created_at: string;
  }

  /** SourcesItems. */
  export interface SourcesItems {
    /** ID of the source. */
    id: string;
    /** List of rules. */
    rules: Rules[];
  }

  /** Payload describing a source list item. */
  export interface SourcesListItems {
    /** ID of the source. */
    id: string;
    /** Name of the source. */
    name: string;
    /** List of rules. */
    rules?: RulesGet[];
  }

  /** Subscription object. */
  export interface Subscription {
    /** Subscription ID. */
    id: string;
    /** Subscription name. */
    name: string;
    /** Subscription description. */
    description: string;
    /** Last updated time. */
    updated_at: string;
    /** From Email ID (it will be displayed only in case of smtp_ibm destination type). */
    from?: string;
    /** The type of destination. */
    destination_type: string;
    /** The destination ID. */
    destination_id: string;
    /** The destination name. */
    destination_name: string;
    /** Topic ID. */
    topic_id: string;
    /** Topic name. */
    topic_name: string;
    attributes?: SubscriptionAttributes;
    /** Subscription accepts additional properties. */
    [propName: string]: any;
  }

  /** SubscriptionAttributes. */
  export interface SubscriptionAttributes {
    /** SubscriptionAttributes accepts additional properties. */
    [propName: string]: any;
  }

  /** SubscriptionCreateAttributes. */
  export interface SubscriptionCreateAttributes {}

  /** Subscription list object. */
  export interface SubscriptionList {
    /** Number of subscriptions. */
    total_count: number;
    /** Current offset. */
    offset: number;
    /** limit to show subscriptions. */
    limit: number;
    /** List of subscriptions. */
    subscriptions: SubscriptionListItem[];
    /** Response having URL of the page. */
    first?: PageHrefResponse;
    /** Response having URL of the page. */
    previous?: PageHrefResponse;
    /** Response having URL of the page. */
    next?: PageHrefResponse;
  }

  /** Subscription list item. */
  export interface SubscriptionListItem {
    /** ID of the subscription. */
    id: string;
    /** Name of the subscription. */
    name: string;
    /** Description of the subscription. */
    description: string;
    /** ID of the destination. */
    destination_id: string;
    /** Name of the destination. */
    destination_name?: string;
    /** The type of destination. */
    destination_type: string;
    /** ID of the topic. */
    topic_id: string;
    /** Name of the topic. */
    topic_name?: string;
    /** Last updated time of the subscription. */
    updated_at: string;
  }

  /** SubscriptionUpdateAttributes. */
  export interface SubscriptionUpdateAttributes {}

  /** Payload describing a tags list request. */
  export interface TagsSubscriptionList {
    /** Total number of tags. */
    total_count: number;
    /** Current offset. */
    offset: number;
    /** limit to show tags. */
    limit: number;
    /** List of tags. */
    tag_subscriptions: TagsSubscriptionListItem[];
    /** Response having URL of the page. */
    first?: PageHrefResponse;
    /** Response having URL of the page. */
    previous?: PageHrefResponse;
    /** Response having URL of the page. */
    next?: PageHrefResponse;
  }

  /** Tags subscription object. */
  export interface TagsSubscriptionListItem {
    /** Subscription Tag ID. */
    id: string;
    /** Unique identifier of the device. */
    device_id: string;
    /** The name of the tag its subscribed. */
    tag_name: string;
    /** The user identifier for the device registration. */
    user_id?: string;
    /** Updated at. */
    updated_at: string;
  }

  /** Template object. */
  export interface Template {
    /** Template ID. */
    id: string;
    /** Template name. */
    name: string;
    /** Template description. */
    description: string;
    /** The type of template. */
    type: string;
    /** Subscription count. */
    subscription_count: number;
    /** Names of subscriptions. */
    subscription_names: string[];
    /** Updated at. */
    updated_at: string;
  }

  /** TemplateConfigOneOf. */
  export interface TemplateConfigOneOf {}

  /** Payload describing a template list request. */
  export interface TemplateList {
    /** Total number of templates. */
    total_count: number;
    /** Current offset. */
    offset: number;
    /** limit to show templates. */
    limit: number;
    /** List of templates. */
    templates: Template[];
    /** Response having URL of the page. */
    first?: PageHrefResponse;
    /** Response having URL of the page. */
    previous?: PageHrefResponse;
    /** Response having URL of the page. */
    next?: PageHrefResponse;
  }

  /** Payload describing a template get request. */
  export interface TemplateResponse {
    /** Template ID. */
    id: string;
    /** Template name. */
    name: string;
    /** Template description. */
    description?: string;
    /** The type of template. */
    type: string;
    params: TemplateConfigOneOf;
    /** Created time. */
    created_at: string;
  }

  /** Destination test object. */
  export interface TestDestinationResponse {
    /** test destiantion status. */
    status: string;
  }

  /** Topic object. */
  export interface Topic {
    /** Autogenerated topic ID. */
    id: string;
    /** Description of the topic. */
    description: string;
    /** Name of the topic. */
    name: string;
    /** Last time the topic was updated. */
    updated_at: string;
    /** Number of sources. */
    source_count: number;
    /** List of sources. */
    sources: SourcesListItems[];
    /** Number of subscriptions. */
    subscription_count: number;
    /** List of subscriptions. */
    subscriptions: SubscriptionListItem[];
  }

  /** Topic list object. */
  export interface TopicList {
    /** Number of topics. */
    total_count: number;
    /** Current offset. */
    offset: number;
    /** limit to show subscriptions. */
    limit: number;
    /** List of topics. */
    topics: TopicsListItem[];
    /** Response having URL of the page. */
    first?: PageHrefResponse;
    /** Response having URL of the page. */
    previous?: PageHrefResponse;
    /** Response having URL of the page. */
    next?: PageHrefResponse;
  }

  /** Topic object. */
  export interface TopicResponse {
    /** Autogenerated topic ID. */
    id: string;
    /** Name of the topic. */
    name: string;
    /** Description of the topic. */
    description: string;
    /** Last time the topic was updated. */
    created_at: string;
  }

  /** Topic list item object. */
  export interface TopicsListItem {
    /** Autogenerated topic ID. */
    id: string;
    /** Name of the topic. */
    name: string;
    /** Description of the topic. */
    description: string;
    /** Number of sources. */
    source_count: number;
    /** List of source names. */
    sources_names: string[];
    /** Number of subscriptions. */
    subscription_count: number;
  }

  /** The email ids or phone numbers. */
  export interface UpdateAttributesInvited {
    /** The email ids or phone numbers to be invited. */
    add?: string[];
    /** The email ids or phone numbers for removal. */
    remove?: string[];
  }

  /** The email ids or phone numbers. */
  export interface UpdateAttributesSubscribed {
    /** The email ids or phone numbers to be unsubscribed. */
    remove?: string[];
  }

  /** The email ids or phone numbers. */
  export interface UpdateAttributesUnsubscribed {
    /** The email ids or phone numbers to be unsubscribed. */
    remove?: string[];
  }

  /** Destination verification object. */
  export interface VerificationResponse {
    /** verification type. */
    type: string;
    /** verification status. */
    verification: string;
  }

  /** Payload describing a Chrome destination configuration. */
  export interface DestinationConfigOneOfChromeDestinationConfig extends DestinationConfigOneOf {
    /** FCM api_key. */
    api_key: string;
    /** Website url. */
    website_url: string;
    /** Chrome VAPID public key. */
    public_key?: string;
    /** If pre prod enabled. */
    pre_prod?: boolean;
  }

  /** Payload describing a code engine destination configuration. */
  export interface DestinationConfigOneOfCodeEngineDestinationConfig
    extends DestinationConfigOneOf {
    /** URL of code engine. */
    url?: string;
    /** HTTP method of code engine. */
    verb?: string;
    /** The code engine destination type. */
    type: string;
    /** CRN of the code engine project. */
    project_crn?: string;
    /** name of the code engine job. */
    job_name?: string;
    /** Custom headers (Key-Value pair) for webhook call. */
    custom_headers?: JsonObject;
    /** List of sensitive headers from custom headers. */
    sensitive_headers?: string[];
  }

  /** Payload describing a custom Domain Email destination configuration. */
  export interface DestinationConfigOneOfCustomDomainEmailDestinationConfig
    extends DestinationConfigOneOf {
    /** Email Domain. */
    domain: string;
    /** The DKIM attributes. */
    dkim?: DKIMAttributes;
    /** The SPF attributes. */
    spf?: SPFAttributes;
  }

  /** Payload describing an FCM destination configuration. project_id, private_key and client_email for FCM HTTP v1 APIs. */
  export interface DestinationConfigOneOfFCMDestinationConfig extends DestinationConfigOneOf {
    /** Deprecated: FCM server_key. */
    server_key?: string;
    /** Deprecated: FCM sender_id. */
    sender_id?: string;
    /** If pre prod enabled. */
    pre_prod?: boolean;
    /** FCM project_id. */
    project_id?: string;
    /** FCM private_key. */
    private_key?: string;
    /** FCM client_email. */
    client_email?: string;
  }

  /** Payload describing a Firefox destination configuration. */
  export interface DestinationConfigOneOfFirefoxDestinationConfig extends DestinationConfigOneOf {
    /** Website url. */
    website_url: string;
    /** Chrome VAPID public key. */
    public_key?: string;
    /** If pre prod enabled. */
    pre_prod?: boolean;
  }

  /** Payload describing a Huawei destination configuration. */
  export interface DestinationConfigOneOfHuaweiDestinationConfig extends DestinationConfigOneOf {
    /** ClientID for the Huawei account oauth. */
    client_id: string;
    /** ClientSecret for the Huawei account oauth. */
    client_secret: string;
    /** If pre prod enabled. */
    pre_prod?: boolean;
  }

  /** Payload describing a Cloud Object Storage destination configuration. */
  export interface DestinationConfigOneOfIBMCloudObjectStorageDestinationConfig
    extends DestinationConfigOneOf {
    /** Bucket Name for Cloud Object Storage. */
    bucket_name: string;
    /** Instance Id of Cloud Object Storage. */
    instance_id: string;
    /** End Point of Cloud Object Storage. */
    endpoint: string;
  }

  /** Payload describing an iOS destination configuration. */
  export interface DestinationConfigOneOfIOSDestinationConfig extends DestinationConfigOneOf {
    /** Authentication type (p8 or p12). */
    cert_type: string;
    /** Sandbox mode for iOS destinations. */
    is_sandbox: boolean;
    /** Password for certificate (Required when cert_type is p12). */
    password?: string;
    /** Key ID for token (Required when cert_type is p8). */
    key_id?: string;
    /** Team ID for token (Required when cert_type is p8). */
    team_id?: string;
    /** Bundle ID for token (Required when cert_type is p8). */
    bundle_id?: string;
    /** If pre prod enabled. */
    pre_prod?: boolean;
  }

  /** Payload describing a MS Teams destination configuration. */
  export interface DestinationConfigOneOfMSTeamsDestinationConfig extends DestinationConfigOneOf {
    /** URL of MS Teams Incoming Notifications. */
    url: string;
  }

  /** Payload describing a PagerDuty destination configuration. */
  export interface DestinationConfigOneOfPagerDutyDestinationConfig extends DestinationConfigOneOf {
    /** API Key for the PagerDuty account. */
    api_key: string;
    /** Routing Key (Integration Key) for the team in PagerDuty account. */
    routing_key: string;
  }

  /** Payload describing a Safari destination configuration. */
  export interface DestinationConfigOneOfSafariDestinationConfig extends DestinationConfigOneOf {
    /** Authentication type p12. */
    cert_type: string;
    /** Password for certificate (Required when cert_type is p12). */
    password: string;
    /** Website url. */
    website_url: string;
    /** Website url. */
    website_name: string;
    /** Website url. */
    url_format_string: string;
    /** Website url. */
    website_push_id: string;
    /** If pre prod enabled. */
    pre_prod?: boolean;
  }

  /** Payload describing a ServiceNow destination configuration. */
  export interface DestinationConfigOneOfServiceNowDestinationConfig
    extends DestinationConfigOneOf {
    /** ClientID for the ServiceNow account oauth. */
    client_id: string;
    /** ClientSecret for the ServiceNow account oauth. */
    client_secret: string;
    /** Username for ServiceNow account REST API. */
    username: string;
    /** Password for ServiceNow account REST API. */
    password: string;
    /** Instance name for ServiceNow account. */
    instance_name: string;
  }

  /** Payload describing a Slack webhook destination configuration. */
  export interface DestinationConfigOneOfSlackDestinationConfig extends DestinationConfigOneOf {
    /** URL of Slack Incoming Notifications. */
    url: string;
    /** The Slack Destination type. */
    type: string;
  }

  /** Payload describing a Slack direct message destination configuration. */
  export interface DestinationConfigOneOfSlackDirectMessageDestinationConfig
    extends DestinationConfigOneOf {
    /** Token of slack application. */
    token: string;
    /** The Slack Destination type. */
    type: string;
  }

  /** Payload describing a webhook destination configuration. */
  export interface DestinationConfigOneOfWebhookDestinationConfig extends DestinationConfigOneOf {
    /** URL of webhook. */
    url: string;
    /** HTTP method of webhook. */
    verb: string;
    /** Custom headers (Key-Value pair) for webhook call. */
    custom_headers?: JsonObject;
    /** List of sensitive headers from custom headers. */
    sensitive_headers?: string[];
  }

  /** The attributes reponse for an email destination. */
  export interface SubscriptionAttributesCustomEmailAttributesResponse
    extends SubscriptionAttributes {
    /** The email id string. */
    invited?: EmailAttributesResponseInvitedItems[];
    /** The unsubscribe list. */
    subscribed?: EmailAttributesResponseSubscribedUnsubscribedItems[];
    /** The subscribed list. */
    unsubscribed?: EmailAttributesResponseSubscribedUnsubscribedItems[];
    /** Whether to add the notification payload to the email. */
    add_notification_payload: boolean;
    /** The email address to reply to. */
    reply_to_mail: string;
    /** The email name to reply to. */
    reply_to_name: string;
    /** The email name of From. */
    from_name: string;
    /** The email from. */
    from_email: string;
    /** The templete id for notification. */
    template_id_notification?: string;
    /** The templete id for invitation. */
    template_id_invitation?: string;
  }

  /** Custom SMS attributes object. */
  export interface SubscriptionAttributesCustomSMSAttributesResponse
    extends SubscriptionAttributes {
    /** The subscribed list. */
    subscribed?: SMSAttributesItems[];
    /** The unsubscribe list. */
    unsubscribed?: SMSAttributesItems[];
    /** The SMS number string. */
    invited?: SMSInviteAttributesItems[];
  }

  /** The attributes reponse for an email destination. */
  export interface SubscriptionAttributesEmailAttributesResponse extends SubscriptionAttributes {
    /** The email id string. */
    invited?: EmailAttributesResponseInvitedItems[];
    /** The unsubscribe list. */
    subscribed?: EmailAttributesResponseSubscribedUnsubscribedItems[];
    /** The subscribed list. */
    unsubscribed?: EmailAttributesResponseSubscribedUnsubscribedItems[];
    /** Whether to add the notification payload to the email. */
    add_notification_payload: boolean;
    /** The email address to reply to. */
    reply_to_mail: string;
    /** The email name to reply to. */
    reply_to_name: string;
    /** The email name of From. */
    from_name: string;
  }

  /** SMS attributes object. */
  export interface SubscriptionAttributesSMSAttributesResponse extends SubscriptionAttributes {
    /** The subscribed list. */
    subscribed?: SMSAttributesItems[];
    /** The unsubscribe list. */
    unsubscribed?: SMSAttributesItems[];
    /** The SMS numder string. */
    invited?: SMSInviteAttributesItems[];
  }

  /** The attributes for a ServiceNow notification. */
  export interface SubscriptionAttributesServiceNowAttributesResponse
    extends SubscriptionAttributes {
    /** Assigned name from ServiceNow account. */
    assigned_to?: string;
    /** Assigned group name from ServiceNow account. */
    assignment_group?: string;
  }

  /** The attributes for a Slack notification. */
  export interface SubscriptionAttributesSlackAttributesResponse extends SubscriptionAttributes {
    /** Attachment Color for Slack Notification. */
    attachment_color?: string;
    /** ID of Base64 converted JSON Slack Blocks w/o Handlebars. */
    template_id_notification?: string;
  }

  /** The attributes for a slack direct message. */
  export interface SubscriptionAttributesSlackDirectMessageAttributesResponse
    extends SubscriptionAttributes {
    /** List of channels. */
    channels?: ChannelCreateAttributes[];
    /** ID of Base64 converted JSON Slack Blocks w/o Handlebars. */
    template_id_notification?: string;
  }

  /** The attributes for a webhook notification. */
  export interface SubscriptionAttributesWebhookAttributesResponse extends SubscriptionAttributes {
    /** Signing webhook attributes. */
    signing_enabled: boolean;
    /** Decision for Notification Payload to be added. */
    add_notification_payload: boolean;
  }

  /** The attributes for an email notification. */
  export interface SubscriptionCreateAttributesCustomEmailAttributes
    extends SubscriptionCreateAttributes {
    /** The email id string. */
    invited: string[];
    /** Whether to add the notification payload to the email. */
    add_notification_payload: boolean;
    /** The email address to reply to. */
    reply_to_mail: string;
    /** The email name to reply to. */
    reply_to_name: string;
    /** The email name of From. */
    from_name: string;
    /** The email from. */
    from_email: string;
    /** The templete id for notification. */
    template_id_notification?: string;
    /** The templete id for invitation. */
    template_id_invitation?: string;
  }

  /** The attributes for an custom sms notification. */
  export interface SubscriptionCreateAttributesCustomSMSAttributes
    extends SubscriptionCreateAttributes {
    /** The sms id string. */
    invited: string[];
  }

  /** The attributes for an email notification. */
  export interface SubscriptionCreateAttributesEmailAttributes
    extends SubscriptionCreateAttributes {
    /** The email id string. */
    invited: string[];
    /** Whether to add the notification payload to the email. */
    add_notification_payload: boolean;
    /** The email address to reply to. */
    reply_to_mail: string;
    /** The email name to reply to. */
    reply_to_name: string;
    /** The email name of From. */
    from_name: string;
  }

  /** The attributes for an FCM notification. */
  export interface SubscriptionCreateAttributesFCMAttributes extends SubscriptionCreateAttributes {}

  /** The attributes for an sms notification. */
  export interface SubscriptionCreateAttributesSMSAttributes extends SubscriptionCreateAttributes {
    /** The sms id string. */
    invited: string[];
  }

  /** The attributes for a ServiceNow notification. */
  export interface SubscriptionCreateAttributesServiceNowAttributes
    extends SubscriptionCreateAttributes {
    /** Name of user ServiceNow incident will be assigned to. */
    assigned_to?: string;
    /** Group Name to which incident will be assigned to. */
    assignment_group?: string;
  }

  /** The attributes for a slack notification. */
  export interface SubscriptionCreateAttributesSlackAttributes
    extends SubscriptionCreateAttributes {
    /** Attachment Color for the slack message. */
    attachment_color?: string;
    /** ID of Base64 converted JSON Slack Blocks w/o Handlebars. */
    template_id_notification?: string;
  }

  /** The attributes for a slack direct message. */
  export interface SubscriptionCreateAttributesSlackDirectMessageAttributes
    extends SubscriptionCreateAttributes {
    /** List of channels. */
    channels?: ChannelCreateAttributes[];
    /** ID of Base64 converted JSON Slack Blocks w/o Handlebars. */
    template_id_notification?: string;
  }

  /** The attributes for a webhook notification. */
  export interface SubscriptionCreateAttributesWebhookAttributes
    extends SubscriptionCreateAttributes {
    /** Signing webhook attributes. */
    signing_enabled?: boolean;
    /** ID of Base64 converted JSON webhook Blocks w/o Handlebars. */
    template_id_notification?: string;
  }

  /** The attributes for an email notification. */
  export interface SubscriptionUpdateAttributesCustomEmailUpdateAttributes
    extends SubscriptionUpdateAttributes {
    /** The email ids or phone numbers. */
    invited?: UpdateAttributesInvited;
    /** Whether to add the notification payload to the email. */
    add_notification_payload: boolean;
    /** The email address to reply to. */
    reply_to_mail: string;
    /** The email name to reply to. */
    reply_to_name: string;
    /** The email name of From. */
    from_name: string;
    /** The email from. */
    from_email: string;
    /** The email ids or phone numbers. */
    subscribed?: UpdateAttributesSubscribed;
    /** The email ids or phone numbers. */
    unsubscribed?: UpdateAttributesUnsubscribed;
    /** The templete id for notification. */
    template_id_notification?: string;
    /** The templete id for invitation. */
    template_id_invitation?: string;
  }

  /** SMS attributes object. */
  export interface SubscriptionUpdateAttributesCustomSMSUpdateAttributes
    extends SubscriptionUpdateAttributes {
    /** The email ids or phone numbers. */
    invited?: UpdateAttributesInvited;
    /** The email ids or phone numbers. */
    subscribed?: UpdateAttributesSubscribed;
    /** The email ids or phone numbers. */
    unsubscribed?: UpdateAttributesUnsubscribed;
  }

  /** The attributes for an email notification. */
  export interface SubscriptionUpdateAttributesEmailUpdateAttributes
    extends SubscriptionUpdateAttributes {
    /** The email ids or phone numbers. */
    invited?: UpdateAttributesInvited;
    /** Whether to add the notification payload to the email. */
    add_notification_payload: boolean;
    /** The email address to reply to. */
    reply_to_mail: string;
    /** The email name to reply to. */
    reply_to_name: string;
    /** The email name of From. */
    from_name: string;
    /** The email ids or phone numbers. */
    subscribed?: UpdateAttributesSubscribed;
    /** The email ids or phone numbers. */
    unsubscribed?: UpdateAttributesUnsubscribed;
  }

  /** SMS attributes object. */
  export interface SubscriptionUpdateAttributesSMSUpdateAttributes
    extends SubscriptionUpdateAttributes {
    /** The email ids or phone numbers. */
    invited?: UpdateAttributesInvited;
    /** The email ids or phone numbers. */
    subscribed?: UpdateAttributesSubscribed;
    /** The email ids or phone numbers. */
    unsubscribed?: UpdateAttributesUnsubscribed;
  }

  /** The attributes for a ServiceNow notification. */
  export interface SubscriptionUpdateAttributesServiceNowAttributes
    extends SubscriptionUpdateAttributes {
    /** Name of user ServiceNow incident will be assigned to. */
    assigned_to?: string;
    /** Group Name to which incident will be assigned to. */
    assignment_group?: string;
  }

  /** The attributes for a slack notification. */
  export interface SubscriptionUpdateAttributesSlackAttributes
    extends SubscriptionUpdateAttributes {
    /** Attachment Color for the slack message. */
    attachment_color?: string;
    /** ID of Base64 converted JSON Slack Blocks w/o Handlebars. */
    template_id_notification?: string;
  }

  /** The attributes for a slack direct message. */
  export interface SubscriptionUpdateAttributesSlackDirectMessageUpdateAttributes
    extends SubscriptionUpdateAttributes {
    /** List of channels. */
    channels?: ChannelUpdateAttributes[];
    /** ID of Base64 converted JSON Slack Blocks w/o Handlebars. */
    template_id_notification?: string;
  }

  /** The attributes for a webhook notification. */
  export interface SubscriptionUpdateAttributesWebhookAttributes
    extends SubscriptionUpdateAttributes {
    /** Signing webhook attributes. */
    signing_enabled?: boolean;
    /** ID of Base64 converted JSON webhook Blocks w/o Handlebars. */
    template_id_notification?: string;
  }

  /** Payload describing an email template configuration. */
  export interface TemplateConfigOneOfEmailTemplateConfig extends TemplateConfigOneOf {
    /** Template body(Base64 encoded). */
    body: string;
    /** The template subject. */
    subject?: string;
  }

  /** Payload describing a slack template configuration. */
  export interface TemplateConfigOneOfSlackTemplateConfig extends TemplateConfigOneOf {
    /** Template body(Base64 encoded). */
    body: string;
  }

  /** Payload describing a webhook template configuration. */
  export interface TemplateConfigOneOfWebhookTemplateConfig extends TemplateConfigOneOf {
    /** Template body(Base64 encoded). */
    body: string;
  }

  /*************************
   * pager classes
   ************************/

  /**
   * SourcesPager can be used to simplify the use of listSources().
   */
  export class SourcesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: EventNotificationsV1;

    protected params: EventNotificationsV1.ListSourcesParams;

    /**
     * Construct a SourcesPager object.
     *
     * @param {EventNotificationsV1}  client - The service client instance used to invoke listSources()
     * @param {Object} params - The parameters to be passed to listSources()
     * @constructor
     * @returns {SourcesPager}
     */
    constructor(client: EventNotificationsV1, params: EventNotificationsV1.ListSourcesParams) {
      if (params && params.offset) {
        throw new Error(`the params.offset field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listSources().
     * @returns {Promise<EventNotificationsV1.SourceListItem[]>}
     */
    public async getNext(): Promise<EventNotificationsV1.SourceListItem[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.offset = this.pageContext.next;
      }
      const response = await this.client.listSources(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'offset');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.sources;
    }

    /**
     * Returns all results by invoking listSources() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<EventNotificationsV1.SourceListItem[]>}
     */
    public async getAll(): Promise<EventNotificationsV1.SourceListItem[]> {
      const results: SourceListItem[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * TopicsPager can be used to simplify the use of listTopics().
   */
  export class TopicsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: EventNotificationsV1;

    protected params: EventNotificationsV1.ListTopicsParams;

    /**
     * Construct a TopicsPager object.
     *
     * @param {EventNotificationsV1}  client - The service client instance used to invoke listTopics()
     * @param {Object} params - The parameters to be passed to listTopics()
     * @constructor
     * @returns {TopicsPager}
     */
    constructor(client: EventNotificationsV1, params: EventNotificationsV1.ListTopicsParams) {
      if (params && params.offset) {
        throw new Error(`the params.offset field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listTopics().
     * @returns {Promise<EventNotificationsV1.TopicsListItem[]>}
     */
    public async getNext(): Promise<EventNotificationsV1.TopicsListItem[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.offset = this.pageContext.next;
      }
      const response = await this.client.listTopics(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'offset');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.topics;
    }

    /**
     * Returns all results by invoking listTopics() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<EventNotificationsV1.TopicsListItem[]>}
     */
    public async getAll(): Promise<EventNotificationsV1.TopicsListItem[]> {
      const results: TopicsListItem[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * TemplatesPager can be used to simplify the use of listTemplates().
   */
  export class TemplatesPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: EventNotificationsV1;

    protected params: EventNotificationsV1.ListTemplatesParams;

    /**
     * Construct a TemplatesPager object.
     *
     * @param {EventNotificationsV1}  client - The service client instance used to invoke listTemplates()
     * @param {Object} params - The parameters to be passed to listTemplates()
     * @constructor
     * @returns {TemplatesPager}
     */
    constructor(client: EventNotificationsV1, params: EventNotificationsV1.ListTemplatesParams) {
      if (params && params.offset) {
        throw new Error(`the params.offset field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listTemplates().
     * @returns {Promise<EventNotificationsV1.Template[]>}
     */
    public async getNext(): Promise<EventNotificationsV1.Template[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.offset = this.pageContext.next;
      }
      const response = await this.client.listTemplates(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'offset');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.templates;
    }

    /**
     * Returns all results by invoking listTemplates() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<EventNotificationsV1.Template[]>}
     */
    public async getAll(): Promise<EventNotificationsV1.Template[]> {
      const results: Template[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * DestinationsPager can be used to simplify the use of listDestinations().
   */
  export class DestinationsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: EventNotificationsV1;

    protected params: EventNotificationsV1.ListDestinationsParams;

    /**
     * Construct a DestinationsPager object.
     *
     * @param {EventNotificationsV1}  client - The service client instance used to invoke listDestinations()
     * @param {Object} params - The parameters to be passed to listDestinations()
     * @constructor
     * @returns {DestinationsPager}
     */
    constructor(client: EventNotificationsV1, params: EventNotificationsV1.ListDestinationsParams) {
      if (params && params.offset) {
        throw new Error(`the params.offset field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listDestinations().
     * @returns {Promise<EventNotificationsV1.DestinationListItem[]>}
     */
    public async getNext(): Promise<EventNotificationsV1.DestinationListItem[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.offset = this.pageContext.next;
      }
      const response = await this.client.listDestinations(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'offset');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.destinations;
    }

    /**
     * Returns all results by invoking listDestinations() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<EventNotificationsV1.DestinationListItem[]>}
     */
    public async getAll(): Promise<EventNotificationsV1.DestinationListItem[]> {
      const results: DestinationListItem[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * TagsSubscriptionPager can be used to simplify the use of listTagsSubscription().
   */
  export class TagsSubscriptionPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: EventNotificationsV1;

    protected params: EventNotificationsV1.ListTagsSubscriptionParams;

    /**
     * Construct a TagsSubscriptionPager object.
     *
     * @param {EventNotificationsV1}  client - The service client instance used to invoke listTagsSubscription()
     * @param {Object} params - The parameters to be passed to listTagsSubscription()
     * @constructor
     * @returns {TagsSubscriptionPager}
     */
    constructor(
      client: EventNotificationsV1,
      params: EventNotificationsV1.ListTagsSubscriptionParams
    ) {
      if (params && params.offset) {
        throw new Error(`the params.offset field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listTagsSubscription().
     * @returns {Promise<EventNotificationsV1.TagsSubscriptionListItem[]>}
     */
    public async getNext(): Promise<EventNotificationsV1.TagsSubscriptionListItem[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.offset = this.pageContext.next;
      }
      const response = await this.client.listTagsSubscription(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'offset');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.tag_subscriptions;
    }

    /**
     * Returns all results by invoking listTagsSubscription() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<EventNotificationsV1.TagsSubscriptionListItem[]>}
     */
    public async getAll(): Promise<EventNotificationsV1.TagsSubscriptionListItem[]> {
      const results: TagsSubscriptionListItem[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SubscriptionsPager can be used to simplify the use of listSubscriptions().
   */
  export class SubscriptionsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: EventNotificationsV1;

    protected params: EventNotificationsV1.ListSubscriptionsParams;

    /**
     * Construct a SubscriptionsPager object.
     *
     * @param {EventNotificationsV1}  client - The service client instance used to invoke listSubscriptions()
     * @param {Object} params - The parameters to be passed to listSubscriptions()
     * @constructor
     * @returns {SubscriptionsPager}
     */
    constructor(
      client: EventNotificationsV1,
      params: EventNotificationsV1.ListSubscriptionsParams
    ) {
      if (params && params.offset) {
        throw new Error(`the params.offset field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listSubscriptions().
     * @returns {Promise<EventNotificationsV1.SubscriptionListItem[]>}
     */
    public async getNext(): Promise<EventNotificationsV1.SubscriptionListItem[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.offset = this.pageContext.next;
      }
      const response = await this.client.listSubscriptions(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'offset');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.subscriptions;
    }

    /**
     * Returns all results by invoking listSubscriptions() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<EventNotificationsV1.SubscriptionListItem[]>}
     */
    public async getAll(): Promise<EventNotificationsV1.SubscriptionListItem[]> {
      const results: SubscriptionListItem[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * IntegrationsPager can be used to simplify the use of listIntegrations().
   */
  export class IntegrationsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: EventNotificationsV1;

    protected params: EventNotificationsV1.ListIntegrationsParams;

    /**
     * Construct a IntegrationsPager object.
     *
     * @param {EventNotificationsV1}  client - The service client instance used to invoke listIntegrations()
     * @param {Object} params - The parameters to be passed to listIntegrations()
     * @constructor
     * @returns {IntegrationsPager}
     */
    constructor(client: EventNotificationsV1, params: EventNotificationsV1.ListIntegrationsParams) {
      if (params && params.offset) {
        throw new Error(`the params.offset field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listIntegrations().
     * @returns {Promise<EventNotificationsV1.IntegrationListItem[]>}
     */
    public async getNext(): Promise<EventNotificationsV1.IntegrationListItem[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.offset = this.pageContext.next;
      }
      const response = await this.client.listIntegrations(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'offset');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.integrations;
    }

    /**
     * Returns all results by invoking listIntegrations() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<EventNotificationsV1.IntegrationListItem[]>}
     */
    public async getAll(): Promise<EventNotificationsV1.IntegrationListItem[]> {
      const results: IntegrationListItem[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SmtpConfigurationsPager can be used to simplify the use of listSmtpConfigurations().
   */
  export class SmtpConfigurationsPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: EventNotificationsV1;

    protected params: EventNotificationsV1.ListSmtpConfigurationsParams;

    /**
     * Construct a SmtpConfigurationsPager object.
     *
     * @param {EventNotificationsV1}  client - The service client instance used to invoke listSmtpConfigurations()
     * @param {Object} params - The parameters to be passed to listSmtpConfigurations()
     * @constructor
     * @returns {SmtpConfigurationsPager}
     */
    constructor(
      client: EventNotificationsV1,
      params: EventNotificationsV1.ListSmtpConfigurationsParams
    ) {
      if (params && params.offset) {
        throw new Error(`the params.offset field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listSmtpConfigurations().
     * @returns {Promise<EventNotificationsV1.SMTPConfiguration[]>}
     */
    public async getNext(): Promise<EventNotificationsV1.SMTPConfiguration[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.offset = this.pageContext.next;
      }
      const response = await this.client.listSmtpConfigurations(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'offset');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.smtp_configurations;
    }

    /**
     * Returns all results by invoking listSmtpConfigurations() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<EventNotificationsV1.SMTPConfiguration[]>}
     */
    public async getAll(): Promise<EventNotificationsV1.SMTPConfiguration[]> {
      const results: SMTPConfiguration[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }

  /**
   * SmtpUsersPager can be used to simplify the use of listSmtpUsers().
   */
  export class SmtpUsersPager {
    protected _hasNext: boolean;

    protected pageContext: any;

    protected client: EventNotificationsV1;

    protected params: EventNotificationsV1.ListSmtpUsersParams;

    /**
     * Construct a SmtpUsersPager object.
     *
     * @param {EventNotificationsV1}  client - The service client instance used to invoke listSmtpUsers()
     * @param {Object} params - The parameters to be passed to listSmtpUsers()
     * @constructor
     * @returns {SmtpUsersPager}
     */
    constructor(client: EventNotificationsV1, params: EventNotificationsV1.ListSmtpUsersParams) {
      if (params && params.offset) {
        throw new Error(`the params.offset field should not be set`);
      }

      this._hasNext = true;
      this.pageContext = { next: undefined };
      this.client = client;
      this.params = JSON.parse(JSON.stringify(params || {}));
    }

    /**
     * Returns true if there are potentially more results to be retrieved by invoking getNext().
     * @returns {boolean}
     */
    public hasNext(): boolean {
      return this._hasNext;
    }

    /**
     * Returns the next page of results by invoking listSmtpUsers().
     * @returns {Promise<EventNotificationsV1.SMTPUser[]>}
     */
    public async getNext(): Promise<EventNotificationsV1.SMTPUser[]> {
      if (!this.hasNext()) {
        throw new Error('No more results available');
      }

      if (this.pageContext.next) {
        this.params.offset = this.pageContext.next;
      }
      const response = await this.client.listSmtpUsers(this.params);
      const { result } = response;

      let next = null;
      if (result && result.next) {
        if (result.next.href) {
          next = getQueryParam(result.next.href, 'offset');
        }
      }
      this.pageContext.next = next;
      if (!this.pageContext.next) {
        this._hasNext = false;
      }
      return result.users;
    }

    /**
     * Returns all results by invoking listSmtpUsers() repeatedly until all pages of results have been retrieved.
     * @returns {Promise<EventNotificationsV1.SMTPUser[]>}
     */
    public async getAll(): Promise<EventNotificationsV1.SMTPUser[]> {
      const results: SMTPUser[] = [];
      while (this.hasNext()) {
        const nextPage = await this.getNext();
        results.push(...nextPage);
      }
      return results;
    }
  }
}

export = EventNotificationsV1;
